// 3. Eliminate All Natural Numbers!

@def Nat_rec = @the (target: Nat) -> (T: Type) -> (base: T) -> (step: (prev: Nat) -> (almost: T) -> T) -> T
(target) => (T) => (base) => (step) =>
  Nat.ind(target, (_) => T, base, step)

@def Nat_which = @the (target: Nat) -> (T: Type) -> (base: T) -> (step: (prev: Nat) -> T) -> T
(target) => (T) => (base) => (step) =>
  Nat_rec(target)(T)(base)((prev) => (_almost) => step(prev))

@def Nat_iter = @the (target: Nat) -> (T: Type) -> (base: T) -> (step: (almost: T) -> T) -> T
(target) => (T) => (base) => (step) =>
  Nat_rec(target)(T)(base)((_prev) => (almost) => step(almost))

// NOTE We use `y` as target, this will make
//   the definition of `pow` looks more natural.

@def add = @the (Nat) -> (Nat) -> Nat
  (x) => (y) => Nat_iter(y)(Nat)(x)((almost) => add1(almost))

@def mul = @the (Nat) -> (Nat) -> Nat
  (x) => (y) => Nat_iter(y)(Nat)(0)((almost) => add(almost)(x))

@def pow = @the (Nat) -> (Nat) -> Nat
  (x) => (y) => Nat_iter(y)(Nat)(1)((almost) => mul(almost)(x))

@def eight = @let four = add(2)(2)
  add(four)(four)

@show add(4)(3)
@show mul(4)(3)
@show pow(4)(3)

// NOTE We want to define `gauss` (without recursion).
// - We try `Nat_which`, but it does not work;
// - We have a rest and think to define `gauss` we also need `add`;
// - We use `Nat_iter` to define `add`;
// - We use `Nat_rec` and `add` to define `gauss`.

@def gauss = @the (Nat) -> Nat
  (n) => Nat_rec(n)(Nat)(0)((prev) => (almost) => add(add1(prev))(almost))

@show "gauss"
@show gauss(0)
@show gauss(1)
@show gauss(2)
@show gauss(3)
@show gauss(4)
@show gauss(5)
@show gauss(6)
@show gauss(7)
@show gauss(8)
@show gauss(9)
@show gauss(10)

@def factorial = @the (Nat) -> Nat
  (n) => Nat_rec(n)(Nat)(1)((prev) => (almost) => mul(add1(prev))(almost))

@show "factorial"
@show factorial(0)
@show factorial(1)
@show factorial(2)
@show factorial(3)
@show factorial(4)
@show factorial(5)
@show factorial(6)
