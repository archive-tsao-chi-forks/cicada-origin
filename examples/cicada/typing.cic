// How to understand inference rule?
// =================================

// - Split type judgment to two judgments -- check and infer.
// - Judgments should be viewed as proposition (type).
// - The language of inference rule does not use closure.

@data Exp {
  var(name: String): Exp
  fn(name: String, ret: Exp): Exp
  ap(target: Exp, arg: Exp): Exp
}

@data Value {
  fn(name: String, ret: Value, env: Env): Value
}

Env = Map(String, Value)

@data Ty {
  atom(name: String): Ty
  arrow(arg_t: Ty, ret_t: Ty): Ty
}

Ctx = Map(String, Ty)

@data Typing(ctx: Ctx, exp: Exp, t: Ty) {
  lookup_var(
    ctx: Ctx,
    name: String,
    t: Ty,
    lookup: Lookup(ctx, name, t),
  ): Typing(ctx, Exp.var(name), t)

  arrow_intro(
    ctx: Ctx,
    name: String,
    ret: Exp,
    arg_t: Ty,
    ret_t: Ty,
    ret_typing: Typing(Map.extend(ctx, name, arg_t), ret, ret_t),
  ): Typing(ctx, Exp.fn(name, ret), Ty.arrow(arg_t, ret_t))

  arrow_elim(
    ctx: Ctx,
    target: Exp,
    arg: Exp,
    arg_t: Ty,
    ret_t: Ty,
    target_typing: Typing(ctx, target, Ty.arrow(arg_t, ret_t)),
    arg_typing: Typing(ctx, arg, arg_t),
  ): Typing(ctx, Exp.ap(target, arg), ret_t)
}

@data Map(K: Type, V: Type) {
  empty: Map(K, V)
  extend(rest: Map(K, V), key: K, value: V): Map(K, V)
}

@given(K: Type, V: Type)
@data Lookup(map: Map(K, V), key: K, value: V) {
  here: Lookup(Map.extend(map, key, value), key, value)

  @given(any_key: K, any_value: V)
  there(
    rest: Map(K, V),
    rest_lookup: Lookup(rest, key, value),
  ): Lookup(Map.extend(rest, any_key, any_value), key, value)
}

// |- (x) => x : (A) -> A
// ----- (arrow introduction)
// x: A |- x: A
// ------ (lookup type of variable)
// QED

// TODO What should be given?
// - learn from List and Vec.

Typing.arrow_intro(
  Map.empty,
  "x",
  Exp.var("x"),
  Ty.atom("A"),
  Ty.atom("A"),
  Typing.lookup_var(
    Map.extend(Map.empty, "x", Ty.atom("A")),
    "x", Ty.atom("A"),
    Lookup.here,
  )
): Typing(
  Map.empty,
  Exp.fn("x", Exp.var("x")),
  Ty.arrow(Ty.atom("A"), Ty.atom("A")),
)
