@module lang1

@export datatype.Map

// 假设在 datatype 中定义数据构造子时，
// 其类型所代表的是纯逻辑式编程。
// 即所有的关系都是可逆的。

// 双向的类型检查在于，关系的单值性，即关系是否是函数。
// 具体对于 Check 而言，假设第三个参数 t 为输出。
// 注意关系是函数，与有算法计算这个函数还差一步。

// 关于双向类型检查与函数单值性，有一个有趣的 user story。
// 首先要知道 Check 对第三个参数 t 的单值性，将给出函数 infer。
// 假设我想实现函数 check 来自动生成关系 Check 的证明。
// 一、我发现只有当我能 infer ap 的 target，才能 check ap，
// 二、而且，额外地，当我能 infer ap 的 target，我就不光能 check ap，并且也能 infer ap，
// 三、为了 infer ap 的 target 我必须能够 infer fn，
// 四、fn 的 Check 对其第三个参数 t 不具有单值性，因此无法实现 infer，
// 五、为了 fn 而加 annotation 这个新 Exp，并且把类型检查 judgment 分为两个方向的 infer 与 check。

// 为什么说「fn 的 Check 对其第三个参数 t 不具有单值性」？
// 通过把逻辑式转写成函数式，并且用到对变量的赋值，
// 可以自动检测一组 judgment 对某一个参数位置的单值性。

// we can use lower case letters as logic
// variable, because const are in namespaces.

@judgment Check(ctx: Map(String, Ty), exp: Exp, t: Ty) {
  // NOTE Formal arguments of type constructor are considered as given to data constructors.
  // - For examples, the above `ctx`, `exp`, `t` can be viewed as given.

  // NOTE What ever occurs in return type of data constructor, can be given by unification.
  // - Such as the following given `name`.
  Check(ctx, Exp.v(name), t)
  -------------------------------- v
  lookup: Map.Lookup(ctx, name, t)

  Check(ctx, Exp.fn(name, ret), Ty.arrow(arg_t, ret_t))
  ------------------------------------------------------- fn
  ret_ck: Check(Map.extend(ctx, name, arg_t), ret, ret_t)

  Check(ctx, Exp.ap(target, arg), ret_t)
  -------------------------------------- ap
  target_ck: Check(ctx, target, Ty.arrow(arg_t, ret_t))
  arg_ck: Check(ctx, arg, arg_t)

  Check(ctx, Exp.let(name, exp, body), t)
  --------------------------------------- let
  exp_ck: Check(ctx, exp, exp_t)
  body_ck: Check(Map.extend(ctx, name, exp_t), body, t)

  Check(ctx, Exp.zero, Ty.nat)
  ---------------------------- zero

  Check(ctx, Exp.add1(prev), Ty.nat)
  ---------------------------------- add1
  prev_ck: Check(ctx, prev, Ty.nat)

  Check(ctx, Exp.rec(t, target, base, step), t)
  --------------------------------------------- rec
  target_ck: Check(ctx, target, Ty.nat)
  base_ck: Check(ctx, base, t)
  step_ck: Check(ctx, base, Ty.arrow(Ty.nat, Ty.arrow(t, t)))

  Check(ctx, Exp.the(t, exp), t)
  ------------------------------ the
  Check(ctx, exp, t)
}
