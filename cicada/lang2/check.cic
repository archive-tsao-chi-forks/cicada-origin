@module lang2

@judgment Check(ctx: Map(String, Value), exp: Exp, t: Value) {
  Check(ctx, Exp.v(name), t)
  -------------------------------- v
  Map.Lookup(ctx, name, t)

  Check(ctx, Exp.pi(name, arg_t, ret_t), Value.type)
  -------------------------------------------------- pi
  Check(ctx, arg_t, Value.type)
  Check(Map.extend(ctx, name, arg_t_value), ret_t, Value.type)
  @where {
    arg_t_value = Exp.evaluate(Ctx.to_env(ctx), arg_t)
  }

  Check(ctx, Exp.fn(name, ret), Value.pi(arg_t, ret_t_cl))
  ------------------------------------------------------- fn
  Check(Map.extend(ctx, name, arg_t), ret, ret_t)
  @where {
    arg = Value.reflection(arg_t, Neutral.v(name))
    ret_t = Closure.apply(ret_t_cl, arg)
  }

  Check(ctx, Exp.ap(target, arg), ret_t)
  -------------------------------------- ap
  Check(ctx, target, Value.pi(arg_t, ret_t_cl))
  Check(ctx, arg, arg_t)
  @where {
    arg_value = Exp.evaluate(Ctx.to_env(ctx), arg)
    ret_t = Closure.apply(ret_t_cl, arg_value)
  }

  Check(ctx, Exp.sigma(name, car_t, cdr_t), Value.type)
  -------------------------------------------------- sigma
  Check(ctx, car_t, Value.type)
  Check(Map.extend(ctx, name, car_t_value), cdr_t, Value.type)
  @where {
    car_t_value = Exp.evaluate(Ctx.to_env(ctx), car_t)
  }

  Check(ctx, Exp.cons(car, cdr), Value.sigma(car_t, cdr_t_cl))
  ------------------------------------------------------- cons
  Check(ctx, car, car_t)
  Check(ctx, cdr, cdr_t)
  @where {
    car_value = Exp.evaluate(Ctx.to_env(ctx), car)
    cdr_t = Closure.apply(cdr_t_cl, car_value)
  }

  Check(ctx, Exp.car(target), car_t)
  --------------------------------- car
  Check(ctx, target, Value.sigma(car_t, ret_t_cl))

  Check(ctx, Exp.cdr(target), ret_t)
  --------------------------------- cdr
  Check(ctx, target, Value.sigma(car_t, ret_t_cl))
  @where {
    car = Value.reflection(car_t, Neutral.v(name))
    ret_t = Closure.apply(ret_t_cl, car)
  }
}
