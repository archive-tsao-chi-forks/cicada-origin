// in prolog:

// append([], Z, Z).
// append([H | X], Y, [H | Z]):-
//   append(X, Y, Z).

// NOTE Give name to each clause in prolog,
//   is equivalent to datatype definition in language with dependent type.
//   When doing so, there will be no computation in the resulting type (only pattern matching)
//   while dependent type systemt can do more than this.

// in cicada:

@given A: Type
@datatype Append(x: List(A), y: List(A), z: List(A)) {
  null: Append(List.null, z, z)
  @given head: A
  cons(prev: Append(x, y, z)): Append(List.cons(head, x), y, List.cons(head, z))
}

// in cicada with inference syntax:

@given A: Type
@datatype Append(x: List(A), y: List(A), z: List(A)) {
  ----------------------- null
  Append(List.null, z, z)

  @given head: A
  prev: Append(x, y, z)
  ------------------------------------------------- cons
  Append(List.cons(head, x), y, List.cons(head, z))
}
