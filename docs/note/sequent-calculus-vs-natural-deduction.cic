// Why it is easier to prove the existence of normal forms in sequent calculus than natural deduction.

// Every elimination rule in natural deduction are synthetic,
// i.e. reading from bottom to up there are information lost.

// In sequent calculus only the cut rule is synthetic, all other rules are analytic.

// Natural deduction and sequent calculus will always have the same introduction rule,
//   which is called the right rule in sequent calculus.
// And the left rule of sequent calculus
//   is just the currying version of the elimination rule of natural deduction.

// - https://en.wikipedia.org/wiki/Analytic-synthetic_distinction

datatype Either(A: Type, B: Type) {

  // l: A
  // ------------ intro_l
  // Either(A, B)

  intro_l(l: A): Either(A, B)

  // r: B
  // ------------ intro_r
  // Either(A, B)

  intro_r(r: B): Either(A, B)
}

// in natural deduction:

// @given A: Type, B: Type, C: Type
// target: Either(A, B)
// lf: (A) -> C
// rf: (B) -> C
// ------------ Either.elim
// C

Either.elim(Either(A, B), (A) -> C, (B) -> C): C
Either.elim(Either.intro_l(l), lf, rf) = lf(l)
Either.elim(Either.intro_r(r), lf, rf) = rf(r)

// in sequent calculus:

// @given A: Type, B: Type, C: Type
// lf: (A) -> C
// rf: (B) -> C
// ----------------- Either.left
// Either(A, B) -> C

Either.left((A) -> C, (B) -> C): Either(A, B) -> C
Either.left(lf, rf) = {
  case Either.intro_l(l) => lf(l)
  case Either.intro_r(r) => rf(r)
}

// in natural deduction:

datatype Pair(A: Type, B: Type) {

  // fst: A
  // snd: B
  // ---------- intro
  // Pair(A, B)

  intro(fst: A, snd: B): Pair(A, B)
}

// @given A: Type, B: Type
// target: Pair(A, B)
// ------------------ Pair.elim_fst
// A

Pair.elim_fst(Pair(A, B)): A
Pair.elim_fst(Pair.intro(fst, snd)) = fst

// @given A: Type, B: Type
// target: Pair(A, B)
// ------------------ Pair.elim_snd
// B

Pair.elim_snd(Pair(A, B)): B
Pair.elim_snd(Pair.intro(fst, snd)) = snd

// in sequent calculus:

// @given A: Type, B: Type
// fst_f: A -> C
// --------------- Pair.left_fst
// Pair(A, B) -> C

Pair.left_fst(A -> C): Pair(A, B) -> C
Pair.left_fst(fst_f) = (Pair.intro(fst, snd)) => fst_f(fst)

// @given A: Type, B: Type
// snd_f: B -> C
// --------------- Pair.left_snd
// Pair(A, B) -> C

Pair.left_snd(B -> C): Pair(A, B) -> C
Pair.left_snd(snd_f) = (Pair.intro(fst, snd)) => snd_f(snd)
