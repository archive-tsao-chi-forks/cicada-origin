package prelude.structure.order.PartialOrder

import prelude.structure.order.PreOrder

// NOTE No cycle.
// NOTE Can implement:
// - topological sort
class PartialOrder extends PreOrder {
  @given(x: Elem, y: Elem)
  antisymmetric(Under(x, y), Under(y, x)): Equal(x, y)

  // NOTE An alternative axiom for reflexive.
  // - Maybe easier to use.
  // - Maybe other axiom with one argument can have similar alternative.
  @given(x: Elem, y: Elem)
  reflexive_alt(equation: Equal(x, y)): (Under(x, y), Under(y, x)) = {
    (transport(equation, (z: Elem) => Under(x, z), reflexive(x)),
      transport(Equal.swap(equation), (z: Elem) => Under(y, z), reflexive(y)))
  }

  // NOTE The advantage of the above axiom is that it is the reverse of antisymmetric
  // antisymmetric(Under(x, y), Under(y, x)): Equal(x, y)
  // Thus in PartialOrder, to prove Equal is equal to prove two Under's.

  // TODO relation between PartialOrder and Lattice
  (z: Elem) -> (Under(w, z) <-> (Under(x, z), Under(y, z)))
}

class Beneath {
  order: PartialOrder
  x: order.Elem
  y: order.Elem
  strict_under: PreOrder.StrictUnder(order, x, y)
  nothing_in_between(
    z: Elem,
    order.Under(x, z),
    PreOrder.StrictUnder(z, y),
  ): Equal(Elem, z, x)
}
