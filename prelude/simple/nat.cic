import * from "./bool.cic"

Nat : Type = {
  case zero
  case succ(prev : Nat)
}

nat_add : { x, y : Nat -> Nat } = {
  switch x {
    case zero => y
    case succ => succ(nat_add(x.prev, y))
  }
}

nat_mul : { x, y : Nat -> Nat } = {
  switch x {
    case zero => zero
    case succ => nat_add(y, nat_mul(x.prev, y))
  }
}

nat_factorial : { x : Nat -> Nat } = {
  switch x {
    case zero => succ(zero)
    case succ => nat_mul(x, nat_factorial(x.prev))
  }
}

one : Nat = succ(zero)
two : Nat = succ(one)
three : Nat = succ(two)
four : Nat = succ(three)
five : Nat = succ(four)
six : Nat = succ(five)
seven : Nat = succ(six)
eight : Nat = succ(seven)
nine : Nat = succ(eight)
ten : Nat = succ(nine)

@assert_eq nat_add(one, one) two
@assert_eq nat_add(two, two) four
@assert_eq nat_add(three, three) six

@assert_eq nat_mul(one, one) one
@assert_eq nat_mul(two, two) four
@assert_eq nat_mul(three, three) nine

@assert_eq nat_factorial(one) one
@assert_eq nat_factorial(two) two
@assert_eq nat_factorial(three) six

nat_even_p : { x : Nat -> Bool } = {
  switch x {
    case zero => true
    case succ => x.prev switch {
      case zero => false
      case succ => nat_even_p(x.prev.prev)
    }
  }
}

@assert_eq nat_even_p(one) false
@assert_eq nat_even_p(two) true
@assert_eq nat_even_p(three) false
@assert_eq nat_even_p(four) true
@assert_eq nat_even_p(five) false
