import prelude.data.Nat

data Vec(A: Type, length: Nat) {
  VecNull: Vec(A, zero)
  VecCons(# n: Nat, head: A, tail: Vec(A, n)): Vec(A, Nat.Succ(n))
}

Vec = class {
  A: Type
  length: Nat
}

VecNull = class extends Vec {
  length = zero
}

VecCons = class extends Vec {
  n: Nat
  length = succ(n)
  head: A
  tail: Vec(A, n)
}

class Vec {
  A: Type
  length: Nat
}

class VecNull extends Vec {
  length = zero
}

class VecCons extends Vec {
  n: Nat
  length = succ(n)
  head: A
  tail: Vec(A, n)
}

vec_append: {
  # A: Type
  # m, n: Nat
  x: Vec(A, m)
  y: Vec(A, n)
  ---------
  Vec(A, nat_add(m, n))
} = {
  x match {
    vec_null => y
    vec_cons => vec_cons(x.head, vec_append(x.tail, y))
  }
}

vec_map: {
  # A, B: Type
  # n: Nat
  f: { A -> B }
  x: Vec(A, n)
  ---------
  Vec(B, n)
} = {
  x match {
    vec_null => x
    vec_cons => vec_cons(f(x.head), vec_map(f, x.tail))
  }
}

three_zeros: Vec(Nat, three) = {
  vec_cons(zero, vec_cons(zero, vec_cons(zero, vec_null)))
}

three_ones: Vec(Nat, three) = {
  vec_cons(one, vec_cons(one, vec_cons(one, vec_null)))
}
