# partech

- move partech out to its own repo
  - learn more about framework design
  - maybe change style before moving

# TLT

> 强化对类型系统的理解与实现技术。
> - 同时测试 lang2 与 lang3。

- [TLT] 5. Lists, Lists, and More Lists
- [TLT] 6. Precisely How Many?
- [TLT] 7. It All Depends On the Motive
- [TLT] Recess: One Piece at a Time
- [TLT] 8. Pick a Number, Any Number
- [TLT] 9. Double Your Money, Get Twice as Much
- [TLT] 10. It Also Depends On the List
- [TLT] 11. All Lists Are Created Equal
- [TLT] 12. Even Numbers Can Be Odd
- [TLT] 13. Even Haf a Baker's Dozen
- [TLT] 14. There's Safety in Numbers
- [TLT] 15. Imagine That ...
- [TLT] 16. If It's All the Same to You
- [TLT] A. The Way Forward
- [TLT] B. Rules Are Made to Be Spoken

# lang0

> try tagless final style
> - use only the first order part of this style

- how to name type of denotational semantics?
- how to name instance of denotational semantics?

- we do not have good a metaphor when using tagless final style
  - meybe we can learn from OOP, and reuse its metaphor
    - why should we use monkey-patching,
      when we can use typeclass?
      not typeclass, but explicit passing function table
    - class is for "same behavior different data"
      typeclass is for "same behavior different type"
      and "same type (interface) different behavior"
    - typeclass is generaic class,
      like collection or container,
      but more sophisticated.
    - class can be viewed as non generaic typeclass,
      typeclass without type variable.
    - since we are using explicit typeclass,
      we must know the type, then choose the typeclass.
    - use record type to understand class and typeclass,
      class is a record type that can reference to itself,
      typeclass is a record type that have type variables.
  - meybe we should develop a metaphor from denotational semantics textbook
  - meybe we should learn DDD about how to develop a metaphor

- the note about is not well refactored,
  how should we refactor note?

- maybe we can use typeclass (function table) factory to do mutli-dispatching.
  the function will return appropriate different function table for input data.

- If OOP is programming by simulanon,
  and when implementation domain objects
  have a direct mapping to problem domain objects,
  the resulting software is far easier to understand and use.

  Should we use game semantics of type system?

# lang2

> 将 NbE 教程中的 tartlet 升级为 pie

- [lang2] `List`, `List.cons`, `List.null`, `List.rec`
- [lang2] `Vector`
- [lang2] be able to add type annotation to `Exp.fn`

- 如何对某一个类型以及相关的 Exp 作出充分的测试？

- test Equal of lang2.
- test Pi of lang2.
- test Absurd of lang2.

- use native `number` as `Nat`.

- 添加 inductive data type -- 根据类型生成 elim。
  - 归纳类型（Inductive type）的推演规则。
    - Only one abstraction away.

# lang3-old

> namespace

- [lang3] check and report empty module
- [lang3] build up parent module when mount a `@module` -- for using first-level module
- [lang3] be able to use every first-level module without `@import`
- [lang3] be able to readback `Value.mod` -- to first-level module
- [lang3] be able to `@import` specific `Den`
- [lang3] `Mod.Den.namespace` -- transparent -- can use bandings in current module
- [lang3] syntax for `Mod.Den.namespace` -- `@namespace`
- [lang3] `Mod.Den.typecons` -- with its `namespace`
- [lang3] syntax for defining bindings in `Mod.Den.typecons`

> syntax

- [lang3] fix syntax about auto currying -- `f(x, y)` as sugar of `f(x)(y)`

> nested match

- [lang3] more simple rule about pattern variable

- [lang3] be able to add type annotation to `Exp.fn`
  - we will be able to infer such `fn`
  - which might be needed by `@match`

- [lang3] there might be `@match`
  - which will be direct application of `Exp.case_fn`

> improve the readback of recursive expression

- [lang3] We SHOULD NOT `mute_recursive_exp_in_mod` for non recursive `Den`

> structural subtyping

- [lang3] `Value.subtype` -- structural cls
- [lang3] `Value.subtype` -- function type

> domain-driven design

- in terms of domain-driven design, what is the core domain of cicada language? set theory?

> lang3 as cicada

- maybe lang3 can not be cicada,
  because we can not do object-oriented design in lang3.

  - maybe we do not need object-oriented design,
    because we can use explicit function table passing style.

  - maybe we can use object-oriented design
    by record type and higher order functions.

# lang3

> refactoring Exp

- [lang3] `Inferable` absurd
- [lang3] `Inferable` cls
- [lang3] `Inferable` equal
- [lang3] `Inferable` pi
- [lang3] `Inferable` str

- [lang3] `Checker` and `checker`
- [lang3] inline `Check.check`

- [lang3] `Inferer` and `inferer`
- [lang3] inline `Infer.infer`

- [lang3] re-place `Evaluate`'s functions

- [lang3] `Exp` as an intersection of `Repr & Checkable`
  - `Checkable` can override the `checkability` generated by `Inferable`

> refactoring Value

- [lang3] `Value` `Neutral` `Normal`

# lang4

> jojo -- to study normal form and recursion.
> - Can be used to play with "Diagonalization and Self-Reference"

- [lang4] be clear about the semantic of "Diagonalization and Self-Reference"
  - formal systems described in this book can be described as class in cicada
- [lang4] design a normalization algorithm
  - 也比可以用 NbE，也许比一般的 NbE 更复杂。

> try small object style

- function compose and type cut,
  if that is all the message expression should know,
  we can use small object style.

- maybe we can use factory to help double the dispatching in `readback`
