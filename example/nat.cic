class nat_t {}
class zero_t {}
class succ_t { given prev : nat_t }

let zero = {}
let one = { let prev = zero }
let two = { let prev = one }
let three = { let prev = two }

function succ {
  given x : nat_t
  conclude nat_t
  return {
    let prev = x
  }
}

function nat_add {
  given x : nat_t
  given y : nat_t
  conclude nat_t
  return switch x {
    case succ_t => succ(nat_add(x.prev, y))
    case zero_t => y
  }
}

function add1 {
  given x : nat_t
  conclude succ_t
  return {
    let prev = x
  }
}

function add2 {
  given x : nat_t
  conclude succ_t
  return add1(add1(x))
}

let x = add2(zero).prev
let y = two.prev.prev

@accept one : succ_t(zero)
@refuse zero : succ_t(zero)
@refuse zero : succ_t(zero)
@refuse zero : succ_t
@refuse zero : succ_t

@show nat_add(zero, zero)
@equal nat_add(zero, zero) = zero
@equal nat_add(one, zero) = one
@equal nat_add(one, one) = two
