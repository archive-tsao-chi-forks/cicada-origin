# 11. All Lists Are Created Equal

## `vector_append`

Let's write down the types and try to understand `vector_ind` first.

``` cicada
import { add } from "ch03.snapshot.cic"

def vector_ind_t: Type = (
  E: Type,
  length: Nat, target: Vector(E, length),
  motive: (length: Nat, target: Vector(E, length)) -> Type,
  base: motive(0, vecnil),
  step: (
    prev: Nat, head: E, tail: Vector(E, prev),
    almost: motive(prev, tail),
  ) -> motive(add1(prev), vec(head, tail))
) -> motive(length, target)
```

And the type of the function we want is:

``` cicada
def vector_append_t: Type = (
  E: Type,
  m n: Nat,
  x: Vector(E, m),
  y: Vector(E, n),
) -> Vector(E, add(n, m))
```

``` cicada
def vector_append(
  E: Type,
  xl yl: Nat,
  x: Vector(E, xl),
  y: Vector(E, yl),
): Vector(E, add(xl, yl)) =
  let motive(length: Nat, _target: Vector(E, length)): Type = Vector(E, add(length, yl))
  let step(
    prev: Nat, head: E, tail: Vector(E, prev),
    almost: Vector(E, add(prev, yl)),
  ): Vector(E, add(add1(prev), yl)) = vec(head, almost)
  // vector_ind(xl, x, motive, y, (prev, head, _tail, almost) => vec(head, almost))
  vector_ind(xl, x, motive, y, step)

vector_append(Nat, 2, 3, vec! [1, 2], vec! [3, 4, 5])
```

## Try to rule out foolish definitions

One way to rule out foolish definitions of `vector_from_list`
is to prove that transforming the `Vector` back into a `List`
results in an equal `List`.

This requires `list_from_vector`.

``` cicada
def list_from_vector(E: Type, length: Nat, vector: Vector(E, length)): List(E) =
  let motive(length: Nat, target: Vector(E, length)): Type = List(E)
  let step(prev: Nat, head: E, tail: Vector(E, prev), almost: List(E)): List(E) = li(head, almost)
  vector_ind(length, vector, motive, nil, step)

list_from_vector(Nat, 3, vec! [1, 2, 3])
```

For every `List`, transforming it into a `Vector` and back to a `List`
yields a list that is equal to the starting list.
