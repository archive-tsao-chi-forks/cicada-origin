# 10. It Also Depends On the List

## Some examples of `Sigma` type

About `Equal` of `String`.

``` cicada
the Type (bread: String) * Equal(String, bread, "bagel")

the (bread: String) * Equal(String, bread, "bagel")
cons("bagel", same)
```

About `(T: Type) * T`.

``` cicada
the Type (T: Type) * T
the (T: Type) * T cons(Nat, 1)
the (T: Type) * T cons(String, "a")

def add(x: Nat, y: Nat): Nat = nat_rec(x, y, (_prev, almost) => add1(almost))

the (T: Type) * T cons((Nat) -> Nat, add(6))
```

About `Equal` of `List`.

``` cicada
the (food: String) * Equal(List(String), li(food, nil), li("toast", nil))
cons("toast", same)
```

About `Equal` of `Vector`.

``` cicada
import { peas } from "ch07.snapshot.cic"

the (length: Nat) * Vector(String, length)
cons(6, peas(6))

the (length: Nat) * Vector(String, length)
cons(2, vec! ["toast-and-jam", "tea"])
```

## Reading `Pair` and `Sigma` as statement

`(A) * D` can be read as `A and D`.

For example `2 equals 3 and "apple" equals "apple"`,
can be expressed by `(A) * D` as:

``` cicada
the Type (Equal(Nat, 2, 3)) * Equal(String, "apple", "apple")
```

`(x: A) * D` can be read as `there exists A, such that D`.

For example `there exists a list of string that equals to its own reverse`,
can be expressed by `(x: A) * D` as:

``` cicada
import { reverse } from "ch05.snapshot.cic"

def symmetric_list_t: Type =
  (list: List(String)) * Equal(List(String), list, reverse(String, list))

the symmetric_list_t (nil) ** same
the symmetric_list_t (li! ["S", "O", "S"]) ** same
the symmetric_list_t (li! ["A", "B", "B", "A"]) ** same
```

There exists a list of strings such that adding "grape" to the back or the front does the same thing.

``` cicada
import { li_end } from "ch05.snapshot.cic"

def magic_grapes_t: Type =
  (list: List(String)) * Equal(List(String), li_end(String, list, "grape"), li("grape", list))

the magic_grapes_t (li! []) ** same
the magic_grapes_t (li! ["grape"]) ** same
the magic_grapes_t (li! ["grape", "grape"]) ** same
```

## `replicate`

``` cicada
def replicate(E: Type, x: E, length: Nat): Vector(E, length) =
  let motive(target: Nat): Type = Vector(E, target)
  let base: Vector(E, 0) = vecnil
  let step(prev: Nat, almost: Vector(E, prev)): Vector(E, add1(prev)) = vec(x, almost)
  nat_ind(length, motive, base, step)

replicate(String, "hi", 6)
```

## `vector_from_list`
