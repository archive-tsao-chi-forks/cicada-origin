# 14. There's Safety in Numbers

## `Maybe`

In order to pick a specific entry from a list,
we must know what to do when there are not enough entries.

One might say that there may be an entry, but there also may not be.

``` cicada
def Maybe(E: Type): Type = Either(E, Trivial)
def nothing(E: Type): Maybe(E) = inr(sole)
def just(E: Type, x: E): Maybe(E) = inl(x)

the Maybe(Nat) nothing(Nat)
the Maybe(Nat) just(Nat, 1)
the Maybe(Nat) just(Nat, 2)
the Maybe(Nat) just(Nat, 3)
```

## `maybe_head` & `maybe_tail`

``` cicada
def maybe_head(E: Type, list: List(E)): Maybe(E) =
  list_rec(
    list,
    nothing(E),
    (head, _tail, _almost) => just(E, head))

maybe_head(String, li! [])
maybe_head(String, li! ["a"])
maybe_head(String, li! ["a", "b"])
maybe_head(String, li! ["a", "b", "c"])

def maybe_tail(E: Type, list: List(E)): Maybe(List(E)) =
  list_rec(
    list,
    nothing(List(E)),
    (_head, tail, _almost) => just(List(E), tail))

maybe_tail(String, li! [])
maybe_tail(String, li! ["a"])
maybe_tail(String, li! ["a", "b"])
maybe_tail(String, li! ["a", "b", "c"])
```

## `list_ref`

``` cicada
def list_ref_step(E: Type, prev: Nat, almost: (List(E)) -> Maybe(E)): (List(E)) -> Maybe(E) =
  (list) =>
    either_ind(
      maybe_tail(E, list),
      (_) => Maybe(E),
      (tail) => almost(tail),
      (_) => nothing(E))

def list_ref(E: Type, index: Nat): (List(E)) -> Maybe(E) =
  nat_rec(index, maybe_head(E), list_ref_step(E))

list_ref(String, 0, li! ["a", "b", "c"])
list_ref(String, 1, li! ["a", "b", "c"])
list_ref(String, 2, li! ["a", "b", "c"])
list_ref(String, 3, li! ["a", "b", "c"])
list_ref(String, 4, li! ["a", "b", "c"])
```

## `Fin`

To define `vector_ref` a new type is needed:
one that represents only numbers smaller than the length of the `Vector`.

We will define type `Fin(n)` to represents "The set of finite natural number smaller than n".

The type of `Fin(0)` is absurd, let's play with absurd first.

``` cicada
def similarly_absurd(x: Absurd): Absurd = x

similarly_absurd
```

**The Commandment of Absurdities**

Every expression of type Absurd is neutral, and all of them are the same.

Now let's define `Fin`.

``` cicada
def Fin(n: Nat): Type =
  nat_rec(
    n,
    Absurd,
    (prev, almost) => Maybe(almost))

Fin(0)
Fin(1)
Fin(2)
Fin(3)
```

We will use elements of `Fin(n)` to index elements of `Vector(E, add1(n))`.

The first entry in a `Vector(E, addl(n))` is indexed by `fzero(n)`.

We can construct a value for each `Fin(n)` where `n` is greater than zero.
We call this construction `fzero`, because it represents zero
of each "set of finite natural number smaller than n".

``` cicada
def fzero(n: Nat): Fin(add1(n)) = nothing(Fin(n))

fzero(0)
fzero(1)
fzero(2)
fzero(3)
```

Just as `fzero(n)` points at the head of a `Vector(X, addl(n))`,
`faddl` points somewhere in its tail.

For each layer of `Maybe` in the type,
there is a choice between either stopping
with `fzero` (also known as `nothing`) and
continuing with `just` a value from the
smaller type.

``` cicada
def fadd1(n: Nat, prev: Fin(n)): Fin(add1(n)) = just(Fin(n), prev)

fadd1(1, fzero(0))
fadd1(2, fadd1(1, fzero(0)))
fadd1(3, fadd1(2, fadd1(1, fzero(0))))

fadd1(11, fzero(10))
fadd1(12, fadd1(11, fzero(10)))
fadd1(13, fadd1(12, fadd1(11, fzero(10))))
```

## `vector_ref`

``` cicada
def vector_ref(E: Type, length: Nat): (Fin(length), Vector(E, length)) -> E =

  let motive(target: Nat): Type =
    (Fin(target), Vector(E, target)) -> E

  let base: (Fin(0), Vector(E, 0)) -> E =
    (index, vector) => absurd_ind(index, E)

  let step(
    prev: Nat,
    almost: (Fin(prev), Vector(E, prev)) -> E
  ): (Fin(add1(prev)), Vector(E, add1(prev))) -> E =
    (index, vector) =>
      either_ind(
        index,
        (_) => E,
        (prev) => almost(prev, vector_tail(vector)),
        (_) => vector_head(vector))

  nat_ind(length, motive, base, step)

vector_ref(String, 3, fzero(2), vec! ["a", "b", "c"])
vector_ref(String, 3, fadd1(2, fzero(1)), vec! ["a", "b", "c"])
vector_ref(String, 3, fadd1(2, fadd1(1, fzero(0))), vec! ["a", "b", "c"])
```

## Turner's Teaser

TODO

