# 14. There's Safety in Numbers

## `Maybe`

In order to pick a specific entry from a list,
we must know what to do when there are not enough entries.

One might say that there may be an entry, but there also may not be.

``` cicada
def Maybe(E: Type): Type = Either(E, Trivial)
def nothing(E: Type): Maybe(E) = inr(sole)
def just(E: Type, x: E): Maybe(E) = inl(x)

the Maybe(Nat) nothing(Nat)
the Maybe(Nat) just(Nat, 1)
the Maybe(Nat) just(Nat, 2)
the Maybe(Nat) just(Nat, 3)
```

## `maybe_head` & `maybe_tail`

``` cicada
def maybe_head(E: Type, list: List(E)): Maybe(E) =
  list_rec(
    list,
    nothing(E),
    (head, _tail, _almost) => just(E, head))

maybe_head(String, li! [])
maybe_head(String, li! ["a"])
maybe_head(String, li! ["a", "b"])
maybe_head(String, li! ["a", "b", "c"])

def maybe_tail(E: Type, list: List(E)): Maybe(List(E)) =
  list_rec(
    list,
    nothing(List(E)),
    (_head, tail, _almost) => just(List(E), tail))

maybe_tail(String, li! [])
maybe_tail(String, li! ["a"])
maybe_tail(String, li! ["a", "b"])
maybe_tail(String, li! ["a", "b", "c"])
```

## `list_ref`

``` cicada
def list_ref_step(E: Type, prev: Nat, almost: (List(E)) -> Maybe(E)): (List(E)) -> Maybe(E) =
  (list) =>
    either_ind(
      maybe_tail(E, list),
      (_) => Maybe(E),
      (tail) => almost(tail),
      (_) => nothing(E))

def list_ref(E: Type, index: Nat): (List(E)) -> Maybe(E) =
  nat_rec(index, maybe_head(E), list_ref_step(E))

list_ref(String, 0, li! ["a", "b", "c"])
list_ref(String, 1, li! ["a", "b", "c"])
list_ref(String, 2, li! ["a", "b", "c"])
list_ref(String, 3, li! ["a", "b", "c"])
list_ref(String, 4, li! ["a", "b", "c"])
```

## `Fin`

To define `vector_ref` a new type is needed:
one that represents only numbers smaller than the length of the `Vector`.

The type of `Fin(0)` is absurd, let's play with absurd first.

``` cicada
def similarly_absurd(x: Absurd): Absurd = x

similarly_absurd
```

## `vector_ref`
